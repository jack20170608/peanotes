INSERT INTO benchmark_test_result (
  ID,
  TEST_CASE_ID,
  START_DT,
  END_DT,
  TOTAL_TIME_MS,
  STATE,
  SUCCESS,
  ERROR_MSG,
  ERROR_STACK_TRACE,
  TEST_ROUND,
  TOTAL_THREAD_COUNT,
  FAILED_THREAD_COUNT,
  SUCCESS_THREAD_COUNT,
  TOTAL_TRANSACTION_COUNT,
  COMMIT_TRANSACTION_COUNT,
  ROLLBACK_TRANSACTION_COUNT,
  AVG_COMMIT_TIME_MS,
  AVG_ROLLBACK_TIME_MS,
  TPS,
  SUCCESS_RATE
)
SELECT
  i AS ID,
  FLOOR(RANDOM() * 100) + 1 AS TEST_CASE_ID,
  CURRENT_TIMESTAMP - (RANDOM() * 365 * 24 * 60 * 60 * 1000) * INTERVAL '1 millisecond' AS START_DT,
  CURRENT_TIMESTAMP - (RANDOM() * 365 * 24 * 60 * 60 * 1000) * INTERVAL '1 millisecond' AS END_DT,
  FLOOR(RANDOM() * 100000) + 1000 AS TOTAL_TIME_MS,
  CASE
  WHEN RANDOM() < 0.7 THEN 'COMPLETED'
  WHEN RANDOM() < 0.9 THEN 'RUNNING'
  ELSE 'FAILED'
END AS STATE,
    RANDOM() < 0.85 AS SUCCESS,
    CASE
        WHEN RANDOM() < 0.15 THEN 'Test execution timeout'
        WHEN RANDOM() < 0.3 THEN 'Connection refused'
        WHEN RANDOM() < 0.45 THEN 'Database connection lost'
        ELSE NULL
END AS ERROR_MSG,
    CASE
        WHEN RANDOM() < 0.15 THEN 'java.sql.SQLException: Connection timed out...'
        ELSE NULL
END AS ERROR_STACK_TRACE,
    FLOOR(RANDOM() * 10) + 1 AS TEST_ROUND,
    FLOOR(RANDOM() * 100) + 10 AS TOTAL_THREAD_COUNT,
    FLOOR(RANDOM() * 20) AS FAILED_THREAD_COUNT,
    FLOOR(RANDOM() * 100) + 10 - FLOOR(RANDOM() * 20) AS SUCCESS_THREAD_COUNT,
    FLOOR(RANDOM() * 10000) + 1000 AS TOTAL_TRANSACTION_COUNT,
    FLOOR(RANDOM() * 10000) + 500 AS COMMIT_TRANSACTION_COUNT,
    FLOOR(RANDOM() * 500) AS ROLLBACK_TRANSACTION_COUNT,
    ROUND((RANDOM() * 1000 + 50)::numeric, 2) AS AVG_COMMIT_TIME_MS,
    ROUND((RANDOM() * 2000 + 100)::numeric, 2) AS AVG_ROLLBACK_TIME_MS,
    ROUND((RANDOM() * 500 + 10)::numeric, 2) AS TPS,
    ROUND((RANDOM() * 50 + 50)::numeric, 2) AS SUCCESS_RATE
FROM generate_series(1, 1000) AS i;
