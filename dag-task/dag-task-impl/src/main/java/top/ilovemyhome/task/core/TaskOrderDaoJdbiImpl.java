package top.ilovemyhome.task.core;


import com.fasterxml.jackson.core.type.TypeReference;
import org.jdbi.v3.core.Jdbi;
import top.ilovemyhome.commons.common.jackson.JacksonUtil;
import top.ilovemyhome.commons.common.lang.LocalDateUtils;
import top.ilovemyhome.peanotes.commons.jdbi.SqlGenerator;
import top.ilovemyhome.peanotes.commons.jdbi.TableDescription;
import top.ilovemyhome.peanotes.commons.jdbi.dao.BaseDaoJdbiImpl;
import top.ilovemyhome.task.si.TaskContext;
import top.ilovemyhome.task.si.domain.TaskOrder;
import top.ilovemyhome.task.si.TaskOrderDao;
import top.ilovemyhome.task.si.domain.TaskRecord;
import top.ilovemyhome.task.si.enums.OrderType;

import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import static top.ilovemyhome.commons.common.lang.StringConvertUtils.toEnum;

public class TaskOrderDaoJdbiImpl extends BaseDaoJdbiImpl<TaskOrder> implements TaskOrderDao {

    public TaskOrderDaoJdbiImpl(Jdbi jdbi, TaskContext taskContext) {
        super(TableDescription.builder()
            .withName(taskContext.getTaskOrderTableName())
            .withIdAutoGenerate(true)
            .withFieldColumnMap(TaskOrder.FIELD_COLUMN_MAP)
            .withIdField(TaskOrder.ID_FIELD)
            .build(), jdbi);
        taskContext.setTaskOrderDao(this);
    }

    @Override
    public Optional<TaskOrder> findByKey(String key) {
        Objects.requireNonNull(key);
        String sql = getCachedSql(SqlGenerator.SQL_STATEMENT.selectAll)
            + " where key = :key ";
        return find(sql, Map.of("key", key), null).stream().findAny();
    }

    @Override
    public int updateByKey(String taskKey, TaskOrder task) {
        Objects.requireNonNull(task);
        Objects.requireNonNull(taskKey);
        String sql = """
            update t_task_order set
            name = :t.name
            , order_type = :t.order_type
            , attributes = :t.attributes
            , last_update_dt = :t.lastUpdateDt
            where key = :key
            """;
        return update(sql, Map.of("key", taskKey), null, Map.of("t", task));
    }

    @Override
    public int deleteByKey(String key) {
        Objects.requireNonNull(key);
        String sql = """
            delete from t_task_order where key = :key
            """;
        return delete(sql, Map.of("key", key) , null);
    }


    @Override
    protected void registerRowMappers(Jdbi jdbi) {
        jdbi.registerRowMapper(TaskOrder.class, (rs, ctx) -> TaskOrder.builder()
            .withId(rs.getLong(TaskOrder.Field.id.getDbColumn()))
            .withName(rs.getString(TaskRecord.Field.name.getDbColumn()))
            .withKey(rs.getString(TaskOrder.Field.key.getDbColumn()))
            .withOrderType(toEnum(OrderType.class, rs.getString(TaskOrder.Field.orderType.getDbColumn())))
            .withAttributes(JacksonUtil.fromJson(rs.getString(TaskOrder.Field.attributes.getDbColumn()), new TypeReference<>() {
            }))
            .withCreateDt(LocalDateUtils.toLocalDateTime(rs.getTimestamp(TaskRecord.Field.createDt.getDbColumn())))
            .withLastUpdateDt(LocalDateUtils.toLocalDateTime(rs.getTimestamp(TaskRecord.Field.lastUpdateDt.getDbColumn())))
            .build());
    }
}
